#! /usr/bin/python

# Read #define's and translate to Python code.
# Handle #define macros with one argument.
# Anything that isn't recognized or doesn't translate into valid
# Python is ignored.

# Without filename arguments, acts as a filter.
# If one or more filenames are given, output is written to corresponding
# filenames in the local directory, translated to all uppercase, with
# the extension replaced by ".py".

# By passing one or more options of the form "-i regular_expression"
# you can specify additional strings to be ignored.  This is useful
# e.g. to ignore casts to u_long: simply specify "-i '(u_long)'".

# XXX To do:
# - turn trailing C comments into Python comments
# - turn C Boolean operators "&& || !" into Python "and or not"
# - what to do about #if(def)?
# - what to do about macros with multiple parameters?

from __future__ import print_function

import sys, re, getopt, os

p_define = re.compile('^[\t ]*#[\t ]*define[\t ]+([a-zA-Z0-9_]+)[\t ]+')

p_macro = re.compile(
  '^[\t ]*#[\t ]*define[\t ]+'
  '([a-zA-Z0-9_]+)\(([_a-zA-Z][_a-zA-Z0-9]*)\)[\t ]+')

p_enum_start = re.compile('^[\t ]*enum([\t ]+[a-zA-Z0-9_]+)?[\n\t ]+{')
# could not match ``enum\n{'' in rtnetlink.h, PREFIX_...
p_enum_entry = re.compile('^[\t ]*([A-Za-z0-9_]+)[\t ]*(=[^,]*)?')
p_enum_end = re.compile('^[\t ]*}')

p_comment = re.compile(r'/\*([^*]+|\*+[^/])*(\*+/)?')
p_cpp_comment = re.compile('//.*')

ignores = [p_comment, p_cpp_comment]

p_char = re.compile(r"'(\\.[^\\]*|[^\\])'")

p_hex = re.compile(r"0x([0-9a-fA-F]+)L?")

try:
    searchdirs=os.environ['include'].split(';')
except KeyError:
    try:
        searchdirs=os.environ['INCLUDE'].split(';')
    except KeyError:
        searchdirs=['/usr/include']

def main():
    opts, args = getopt.getopt(sys.argv[1:], 'i:')
    for o, a in opts:
        if o == '-i':
            ignores.append(re.compile(a))
    if not args:
        args = ['-']
    for filename in args:
        if filename == '-':
            sys.stdout.write('# Generated by h2py from stdin\n')
            process(sys.stdin, sys.stdout)
        else:
            fp = open(filename, 'r')
            outfile = os.path.basename(filename)
            i = outfile.rfind('.')
            if i > 0: outfile = outfile[:i]
            modname = outfile.upper()
            outfile = modname + '.py'
            outfp = open(outfile, 'w')
            outfp.write('# Generated by h2py from %s\n' % filename)
            process(fp, outfp)
            outfp.close()
            fp.close()

def pytify(body):
    # replace ignored patterns by spaces
    for p in ignores:
        body = p.sub(' ', body)
    # replace char literals by ord(...)
    body = p_char.sub("ord('\\1')", body)
    # Compute negative hexadecimal constants
    start = 0
    UMAX = 2*(sys.maxsize+1)
    while 1:
        m = p_hex.search(body, start)
        if not m: break
        s,e = m.span()
        val = int(body[slice(*m.span(1))], 16)
        if val > sys.maxsize:
            val -= UMAX
            body = body[:s] + "(" + str(val) + ")" + body[e:]
        start = s + 1
    return body

def process(fp, outfp, env = {}):
    lineno = 0
    enum = -1
    whole_stmt = ''
    while 1:
        line = fp.readline()
        if not line: break
        lineno = lineno + 1
        match = p_define.match(line)
        if match:
            # gobble up continuation lines
            while line[-2:] == '\\\n':
                nextline = fp.readline()
                if not nextline: break
                lineno = lineno + 1
                line = line + nextline
            name = match.group(1)
            body = line[match.end():]
            body = pytify(body)
            if name != body.strip():
                ok = 0
                stmt = '%s = %s\n' % (name, body.strip())
                try:
                    exec(whole_stmt + stmt, env)
                except:
                    outfp.write('# H2PY_ERR: %s - define: %s\n' % (fp.name, stmt.strip()))
                    sys.stderr.write('# H2PY_ERR: %s - define: %s\n' % (fp.name, stmt.strip()))
                else:
                    outfp.write(stmt)
                    whole_stmt += stmt
        match = p_macro.match(line)
        if match:
            macro, arg = match.group(1, 2)
            body = line[match.end():]
            body = pytify(body)
            stmt = 'def %s(%s): return %s\n' % (macro, arg, body)
            try:
                exec(whole_stmt + stmt, env)
            except:
                outfp.write('# H2PY_ERR: %s - macro: %s\n' % (fp.name, stmt.strip()))
                sys.stderr.write('# H2PY_ERR: %s - macro: %s\n' % (fp.name, stmt.strip()))
            else:
                outfp.write(stmt)
                whole_stmt += stmt

        if enum >= 0:
            match = p_enum_entry.match(line)
            if match:
                name, assign = match.group(1, 2)
                if assign is None:
                    val = str(enum)
                else:
                    val = assign.split("=")[-1].strip()
                    if val.find(" ") < 0:
                        try:
                            enum = eval(val)
                        except Exception as e:
                            sys.stderr.write('# H2PY_WARN: %s - enum: %s' % (fp.name, line))
                stmt = '%s = %s\n' % (name, val)
                try:
                    exec(whole_stmt + stmt, env)
                except:
                    outfp.write('# H2PY_ERR: %s - enum: %s\n' % (fp.name, stmt.strip()))
                    sys.stderr.write('# H2PY_ERR: %s - enum: %s\n' % (fp.name, stmt.strip()))
                else:
                    outfp.write(stmt)
                    whole_stmt += stmt
                enum += 1
        match = p_enum_start.match(line)
        if match:
            enum = 0
        match = p_enum_end.match(line)
        if match:
            enum = -1


def mymain(indir, outdir):
    for root, dirs, files in os.walk(indir):
        try:
            os.makedirs(os.path.join(outdir, root))
        except OSError as e:
            if e.errno != 17:
                raise
        with open(os.path.join(outdir, root, '__init__.py'), 'w') as initfile:
            initfile.write('from __future__ import absolute_import\n')
            [initfile.write("from .%s import *\n" % d) for d in dirs]
            # if root.endswith(indir):
            #     initfile.write('from .h2err import *\n')

        for fname in files:
            if not fname.endswith(".h"):
                continue

            infname = os.path.join(root, fname)
            with open(infname, 'r') as infile:
                outbase = '%s.py' % fname.rstrip('.h').upper()
                with open(os.path.join(outdir, root, outbase), 'w') as outfile:
                    outfile.write('# Generated by h2py from %s\n\n' % infname)
                    outfile.write('from __future__ import absolute_import\n\n')                    
                    process(infile, outfile)
                with open(os.path.join(outdir, root, '__init__.py'), 'a') as initfile:
                    initfile.write("from .%s import *\n" % outbase.rstrip('.py'))


if __name__ == '__main__':
    # main()
    mymain(sys.argv[1], sys.argv[2])
